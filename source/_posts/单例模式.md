---
title: 单例模式
date: 2019-07-16 16:40:21
tags:
categories: 设计模式
description: 单例模式详解
---

​	单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。

<!-- more -->

## 单例模式三元素

1. 构造方法私有化
2. 私有静态实例属性
3. 公共静态方法提供实例获取的唯一途径，没有实例则创建实例

```java
public class Singleton{
    private static Singleton uniqueInstance;
    private Singleton(){
    }
    public static Singleton getUniqueInstance(){
        ....
        return uniqueInstance;
    }
}
```

## 单例模式的四种实现方式

### 饿汉模式

```java
public class Singleton{
    //类加载时就创建实例，保证唯一性
    private static Singleton uniqueInstance = new Singleton();
    private Singleton(){
    }
    public static Singleton getUniqueInstance(){
        return uniqueInstance;
    }
}
```

优点：线程安全
缺点：不能延迟实例化，造成资源浪费

### 懒汉模式

**Ⅰ线程不安全**

```java
public class Singleton{
    private static Singleton uniqueInstance;
    private Singleton(){
    }
    public static Singleton getUniqueInstance(){
    	if(uniqueInstance == null){
    		//这里会造成线程不安全
            uniqueInstacne = new Singleton();
    	}
        return uniqueInstance;
    }
}
```

这种写法会造成线程不安全，当多个线程同时进入  `if(uniqueInstance == null)`  时会导致创建多个实例。

**Ⅱ 同步方法-线程安全**

```java
public static synchronized Singleton getUniqueInstance(){
    if(uniqueInstance == null){
        uniqueInstacne = new Singleton();
    }
    return uniqueInstance;
}
```

优点：`synchronized` 保证了线程安全，一次只能有一个线程获取实例
缺点：同步方法将会导致程序的性能下降

**Ⅲ 双重校验锁-线程安全**

```java
public class Singleton{
    // volatile 关键字
    private volatile static Singleton uniqueInstance;
    private Singleton(){
    }
    public static Singleton getUniqueInstance(){
    	if(uniqueInstance == null){
            synchronized(Singleton.class){
                // 二次判断是否为空
                if(uniqueInstance == null){
                    uniqueInstacne = new Singleton();
                }
            }
    	}
        return uniqueInstance;
    }
}
```

通过双重校验，只有在实例还未创建时才进行同步，这样做可以提升性能。其中有两个点需要注意：

**(1) 二次判断是否为空**
第一次判是为了判断实例是否存在；对于第二次判断如果没有，假设两个线程都已通过第一层判断则将会创建两个实例
**(2) volatile 关键字**
`uniqueInstacne = new Singleton()`  将分三步执行：

1. 分配 Singleton 类实例需要的内存空间
2. 通过构造函数对内存空间进行初始化
3. 将内存空间地址赋值给 uniqueInstacne 对象

由于JVM的**指令重排序**，执行顺序可能变成1 -> 3 -> 2,当线程 T1 执行了 1，3 后，线程 T2 则误以为 uniqueInstacne 不为空，直接返回，然而 uniqueInstacne 还未被初始化。

### 静态内部类实现

利用**静态内部类在类被加载时并没有被加载，只有被使用时才会加载**的特性来实现单例。
优点：不仅能延迟初始化，还能保证线程安全。

```java
public class Singleton{
    private Singleton(){
        
    }
    
    // 设置一个私有静态内部类，持有一个私有静态实例
    private static class SingletonHolder{
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getUniqueInstance(){
        return SingletonHolder.INSTANCE;
    }
}
```

### 枚举实现

```java
public enum Singleton{
    INSTANCE;
}
```

优点：保证线程安全，并且可以防止**反射攻击和反序列化**，这是其它以上方法不具备的。